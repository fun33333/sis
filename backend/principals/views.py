from rest_framework import viewsets, decorators, status
from rest_framework.permissions import IsAuthenticated
from rest_framework.response import Response
from rest_framework.filters import SearchFilter, OrderingFilter
from django_filters.rest_framework import DjangoFilterBackend
from django.db.models import Q
from django.contrib.auth import get_user_model
from users.permissions import IsSuperAdmin
from .models import Principal
from .serializers import PrincipalSerializer

User = get_user_model()


class PrincipalViewSet(viewsets.ModelViewSet):
    queryset = Principal.objects.all()
    serializer_class = PrincipalSerializer
    permission_classes = [IsAuthenticated]
    
    # Filtering, search, and ordering
    filter_backends = [DjangoFilterBackend, SearchFilter, OrderingFilter]
    filterset_fields = ['campus', 'shift', 'is_currently_active']
    search_fields = ['full_name', 'employee_code', 'email', 'contact_number', 'cnic']
    ordering_fields = ['full_name', 'joining_date', 'created_at']
    ordering = ['-created_at']  # Default ordering
    
    def get_queryset(self):
        """Override to optimize queries and handle filtering"""
        queryset = Principal.objects.select_related('campus', 'user').all()
        
        # Role-based filtering - only super admin can access all principals
        user = self.request.user
        if not user.is_superuser and not user.is_staff:
            queryset = queryset.none()
        
        return queryset
    
    def perform_create(self, serializer):
        """Create principal and auto-generate user account"""
        # Check for existing principal on the same campus + shift
        campus_id = serializer.validated_data.get('campus')
        shift = serializer.validated_data.get('shift')
        
        if campus_id and shift:
            existing_principal = Principal.objects.filter(campus=campus_id, shift=shift).first()
            if existing_principal:
                from rest_framework.exceptions import ValidationError
                shift_display = existing_principal.get_shift_display()
                raise ValidationError({
                    'shift': f'This campus already has a principal for {shift_display} shift: {existing_principal.full_name}'
                })
        
        principal = serializer.save()
        
        # Auto-generate user account
        try:
            # Get employee_code (should be auto-generated by model's save method)
            if principal.employee_code:
                username = principal.employee_code
                default_password = principal.employee_code
                
                # Create user if doesn't exist
                user, created = User.objects.get_or_create(
                    username=username,
                    defaults={
                        'email': principal.email,
                        'is_staff': False,
                        'is_superuser': False,
                    }
                )
                
                # Set default password
                if created:
                    user.set_password(default_password)
                    user.save()
                    
                # Link user to principal
                principal.user = user
                principal.save()
        except Exception as e:
            print(f"Error creating user for principal: {str(e)}")
    
    def perform_update(self, serializer):
        """Update principal and sync user account if needed"""
        # Check if campus, shift, or joining_date changed
        instance: Principal = self.get_object()
        old_campus = instance.campus
        old_shift = instance.shift
        old_joining_date = instance.joining_date
        
        # Save the principal
        principal: Principal = serializer.save()
        
        # Check if any code-generating field changed
        new_campus = principal.campus
        new_shift = principal.shift
        new_joining_date = principal.joining_date
        
        regenerate_code = (
            old_campus != new_campus or
            old_shift != new_shift or
            old_joining_date != new_joining_date
        )
        
        # Regenerate employee code if needed
        if regenerate_code:
            principal.save(regenerate_code=True)
        
        # Update user email if changed
        if principal.user and principal.email:
            principal.user.email = principal.email
            principal.user.save()
    
    @decorators.action(detail=False, methods=['get'])
    def stats(self, request):
        """Get principal statistics"""
        total = self.get_queryset().count()
        active = self.get_queryset().filter(is_currently_active=True).count()
        inactive = total - active
        
        return Response({
            'total': total,
            'active': active,
            'inactive': inactive
        })

